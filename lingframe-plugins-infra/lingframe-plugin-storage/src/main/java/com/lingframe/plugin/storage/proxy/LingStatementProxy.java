package com.lingframe.plugin.storage.proxy;

import com.lingframe.api.context.PluginContextHolder;
import com.lingframe.api.exception.PermissionDeniedException;
import com.lingframe.api.security.AccessType;
import com.lingframe.api.security.PermissionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.sql.*;

@Slf4j
@RequiredArgsConstructor
public class LingStatementProxy implements Statement {

    private final Statement target;
    private final PermissionService permissionService;

    // --- 鉴权逻辑：与 PreparedStatement 类似，只是 SQL 是参数传进来的 ---
    private void checkPermission(String sql) throws SQLException {
        String callerPluginId = PluginContextHolder.get();
        if (callerPluginId == null) return;

        String trimmedSql = sql.trim().toUpperCase();
        AccessType accessType = AccessType.EXECUTE;
        if (trimmedSql.startsWith("SELECT")) accessType = AccessType.READ;
        else if (trimmedSql.startsWith("INSERT") || trimmedSql.startsWith("UPDATE") || trimmedSql.startsWith("DELETE")) accessType = AccessType.WRITE;

        boolean allowed = permissionService.isAllowed(callerPluginId, "storage:sql", accessType);
        permissionService.audit(callerPluginId, "storage:sql", sql, allowed);

        if (!allowed) {
            throw new SQLException(new PermissionDeniedException("Access Denied: " + sql));
        }
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        checkPermission(sql);
        return target.executeQuery(sql);
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        checkPermission(sql);
        return target.executeUpdate(sql);
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        checkPermission(sql);
        return target.execute(sql);
    }

    // --- 省略其他委托方法 ---
    @Override public void close() throws SQLException { target.close(); }
    @Override public boolean isClosed() throws SQLException { return target.isClosed(); }
    @Override public int getMaxFieldSize() throws SQLException { return target.getMaxFieldSize(); }
    @Override public void setMaxFieldSize(int max) throws SQLException { target.setMaxFieldSize(max); }
    @Override public int getMaxRows() throws SQLException { return target.getMaxRows(); }
    @Override public void setMaxRows(int max) throws SQLException { target.setMaxRows(max); }
    @Override public void setEscapeProcessing(boolean enable) throws SQLException { target.setEscapeProcessing(enable); }
    @Override public int getQueryTimeout() throws SQLException { return target.getQueryTimeout(); }
    @Override public void setQueryTimeout(int seconds) throws SQLException { target.setQueryTimeout(seconds); }
    @Override public void cancel() throws SQLException { target.cancel(); }
    @Override public SQLWarning getWarnings() throws SQLException { return target.getWarnings(); }
    @Override public void clearWarnings() throws SQLException { target.clearWarnings(); }
    @Override public void setCursorName(String name) throws SQLException { target.setCursorName(name); }
    @Override public ResultSet getResultSet() throws SQLException { return target.getResultSet(); }
    @Override public int getUpdateCount() throws SQLException { return target.getUpdateCount(); }
    @Override public boolean getMoreResults() throws SQLException { return target.getMoreResults(); }
    @Override public void setFetchDirection(int direction) throws SQLException { target.setFetchDirection(direction); }
    @Override public int getFetchDirection() throws SQLException { return target.getFetchDirection(); }
    @Override public void setFetchSize(int rows) throws SQLException { target.setFetchSize(rows); }
    @Override public int getFetchSize() throws SQLException { return target.getFetchSize(); }
    @Override public int getResultSetConcurrency() throws SQLException { return target.getResultSetConcurrency(); }
    @Override public int getResultSetType() throws SQLException { return target.getResultSetType(); }
    @Override public void addBatch(String sql) throws SQLException { target.addBatch(sql); }
    @Override public void clearBatch() throws SQLException { target.clearBatch(); }
    @Override public int[] executeBatch() throws SQLException { return target.executeBatch(); }
    @Override public Connection getConnection() throws SQLException { return target.getConnection(); }
    @Override public boolean getMoreResults(int current) throws SQLException { return target.getMoreResults(current); }
    @Override public ResultSet getGeneratedKeys() throws SQLException { return target.getGeneratedKeys(); }
    @Override public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException { checkPermission(sql); return target.executeUpdate(sql, autoGeneratedKeys); }
    @Override public int executeUpdate(String sql, int[] columnIndexes) throws SQLException { checkPermission(sql); return target.executeUpdate(sql, columnIndexes); }
    @Override public int executeUpdate(String sql, String[] columnNames) throws SQLException { checkPermission(sql); return target.executeUpdate(sql, columnNames); }
    @Override public boolean execute(String sql, int autoGeneratedKeys) throws SQLException { checkPermission(sql); return target.execute(sql, autoGeneratedKeys); }
    @Override public boolean execute(String sql, int[] columnIndexes) throws SQLException { checkPermission(sql); return target.execute(sql, columnIndexes); }
    @Override public boolean execute(String sql, String[] columnNames) throws SQLException { checkPermission(sql); return target.execute(sql, columnNames); }
    @Override public int getResultSetHoldability() throws SQLException { return target.getResultSetHoldability(); }
    @Override public void setPoolable(boolean poolable) throws SQLException { target.setPoolable(poolable); }
    @Override public boolean isPoolable() throws SQLException { return target.isPoolable(); }
    @Override public void closeOnCompletion() throws SQLException { target.closeOnCompletion(); }
    @Override public boolean isCloseOnCompletion() throws SQLException { return target.isCloseOnCompletion(); }
    @Override public <T> T unwrap(Class<T> iface) throws SQLException { return target.unwrap(iface); }
    @Override public boolean isWrapperFor(Class<?> iface) throws SQLException { return target.isWrapperFor(iface); }
}